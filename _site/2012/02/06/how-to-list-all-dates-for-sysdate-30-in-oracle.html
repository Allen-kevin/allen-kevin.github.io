<p>Discovered an answer to <a href="http://stackoverflow.com/q/9166877/316847">a StackOverflow question I’d posted</a>, and wanted to share.</p>

<h3 id="the-problem">The Problem</h3>
<p>I needed to, within a view, dynamically generate a list of dates before or after sysdate. I wanted to do this so that I could limit some of the records coming back (we have millions but the date range will always be between 31 days before sysdate or 31 says after.</p>

<h3 id="the-solution">The Solution</h3>
<p>In Oracle, the SQL to do this is as follows:</p>

<p><code>SQL
SELECT *
FROM   (SELECT TRUNC(SYSDATE - ROWNUM) DateItem
        FROM   DUAL
        CONNECT BY ROWNUM &lt; 32
        UNION
        SELECT TRUNC(SYSDATE + ROWNUM) DateItem
        FROM   DUAL
        CONNECT BY ROWNUM &lt; 32)DATERANGE; 
</code></p>

<p>This SQL does the following</p>

<ul>
  <li>Uses the dual table (a special table in Oracle as I understand) to scroll through x amount of rows (in this case, 32, because we want to make sure it includes 31 days)</li>
  <li>For each of those, it returns the <code>sysdate - [the number of rows]</code>, or <code>sysdate + [the number of rows]</code> in the case of the second query. It calls this column <code>DT</code>.</li>
  <li>It unions those two queries together, to give the full range of values. This also has the nice effect of removing duplicate dates from the results.</li>
  <li>I then wrap it in a <code>select *</code> statement so I can call it what I want and refer to it later.</li>
</ul>

<p>Learning Oracle as I go, and I’m enjoying discovering these little tricks.</p>
